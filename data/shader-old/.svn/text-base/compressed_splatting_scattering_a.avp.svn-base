<arbvp>
  <variablemap variable="light position world[0]" destination="register 0"/>
  <variablemap variable="light diffuse[0]" destination="register 1"/>
  <variablemap variable="light specular[0]" destination="register 2"/>
  <variablemap variable="light attenuation[0]" destination="register 3"/>
  
  <variablemap variable="mat diffuse" destination="register 4"/>
  <variablemap variable="mat ambient" destination="register 5"/>
  <variablemap variable="mat reflection" destination="register 6"/>
  <variablemap variable="mat flatcolor" destination="register 7"/>
  
  <variablemap variable="mat specular" destination="register 8"/>

  <variablemap variable="normal scale" destination="register 9" />
  
  <variablemap variable="object2world transform inverse" destination="register 10"/>
  <program>
    <![CDATA[
      !!ARBvp1.0
      #---------------------------------------
      # Simple Vertex Lighting Program
      #---------------------------------------
      #Parameter definition
      PARAM mv[4]	     	= { state.matrix.modelview };
      PARAM mvi[4]	 	= { state.matrix.modelview.inverse };
      PARAM mvp[4]	     	= { state.matrix.mvp };
      PARAM w2o[4]              = { program.local[10..13] };
      PARAM lightPosW   	= program.local[0];
      PARAM lightDiffuse 	= program.local[1];
      PARAM lightSpecular 	= program.local[2];
      PARAM lightAttenuation 	= program.local[3];
      PARAM z 	= {0, 0, 1, 0};
      PARAM down		= { 0, 0, 1, 0};
      
      PARAM materialDiffuse	= program.local[4];
      PARAM materialAmbient	= program.local[5];
      PARAM materialReflection	= program.local[6];
      PARAM materialFlatColor 	= program.local[7];
      PARAM materialSpecular 	= program.local[8];

      PARAM normalscale		= program.local[9];
      # Per vertex inputs
      ATTRIB iPos		= vertex.position;
      ATTRIB iCol0		= vertex.color;
      ATTRIB iNorm		= vertex.normal;
      ATTRIB iTex0		= vertex.texcoord[0];
      # Outputs
      OUTPUT oPos		    = result.position;
      OUTPUT oCol0		  = result.color;
      OUTPUT oLightDir	= result.texcoord[0];
      OUTPUT oNormal		= result.texcoord[1];
      # Temporaries
      TEMP scale;
      TEMP objLight;
      TEMP tangLight;
      TEMP norm;
      TEMP tang;
      TEMP binorm;
      
      MOV norm, iNorm;
      
      # Compute tangent from normal
      XPD tang, down, norm;
      DP3 tang.w, tang, tang;
      RSQ tang.w, tang.w;
      MUL tang, tang, tang.w;

      # Compute binormal from normal
      XPD binorm, norm, tang;
      DP3 binorm.w, binorm, binorm;
      RSQ binorm.w, binorm.w;
      MUL binorm, binorm, binorm.w;
      
      #Transform vertex to viewspace
      DP4 oPos.x, mvp[0], iPos;
      DP4 oPos.y, mvp[1], iPos;
      DP4 oPos.z, mvp[2], iPos;
      DP4 oPos.w, mvp[3], iPos;
      
      #Transform light to object space
      DP4 objLight.x, w2o[0], lightPosW;
      DP4 objLight.y, w2o[1], lightPosW;
      DP4 objLight.z, w2o[2], lightPosW;
      DP4 objLight.w, w2o[3], lightPosW;

      ADD objLight, objLight, -iPos;

      #Transform light to tangent space
      DP4 tangLight.x, tang, objLight;
      DP4 tangLight.y, binorm, objLight;
      DP4 tangLight.z, norm, objLight;
      SGE tangLight.w, tangLight.x, tangLight.x;

      #Just pass on normal
      MUL oNormal, normalscale, iTex0;
      
      #calculate vector from vertex to light in object-space
      MOV oLightDir, tangLight;
      
      END
    ]]>
  </program>
</arbvp>
